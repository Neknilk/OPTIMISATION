import joblib
import numpy as np
import os
import csv
from geographiclib.geodesic import Geodesic

geod = Geodesic.WGS84

# Load the pre-trained joblib model
fuel_flow_model_path = r'C:\Users\jayva\Documents\GitHub\OPTIMISATION\CODE\FF model.joblib'
fuel_flow_model = joblib.load(fuel_flow_model_path)

class Particle:
    def __init__(self, num_waypoints, initial_coord, final_coord, altitude, day):
        # Generate waypoints along a Great Circle path
        great_circle_path = self.generate_great_circle_waypoints(initial_coord, final_coord, num_waypoints)

        # Extract latitude and longitude coordinates
        self.waypoints = np.array([[point[0], point[1]] for point in great_circle_path])
        self.velocity = np.random.rand(num_waypoints, 2)
        self.best_waypoints = np.copy(self.waypoints)
        self.best_fitness = float('inf')
        self.altitude = altitude
        self.day = day

    def generate_great_circle_waypoints(self, initial_coord, final_coord, num_waypoints):
        waypoints = []
        for i in range(num_waypoints):
            fraction = i / (num_waypoints - 1)
            point = (
                initial_coord[0] + fraction * (final_coord[0] - initial_coord[0]),
                initial_coord[1] + fraction * (final_coord[1] - initial_coord[1])
            )
            waypoints.append(point)
        return waypoints

def calculate_row(lat, lon):
    lat_i = round((lat + 90) / 180 * 301) 
    lon_i = round((lon + 180) / 360 * 601)
    return (lat_i - 1) * 601 + lon_i - 1

def get_weather_data(day, altitude, latitude, longitude):
    base_directory = r'C:\Users\jayva\Documents\GitHub\OPTIMISATION\DATA\weather'
    tmp_path = os.path.join(base_directory, f'Day_{day}_v_2', f'TMP_date_{day}_alt_{altitude}.csv')
    wind_path = os.path.join(base_directory, f'Day_{day}_v_2', f'WIND_date_{day}_alt_{altitude}.csv')
    wdir_path = os.path.join(base_directory, f'Day_{day}_v_2', f'WDIR_date_{day}_alt_{altitude}.csv')

    try:
        tmp = np.genfromtxt(tmp_path, delimiter=',')
        wind = np.genfromtxt(wind_path, delimiter=',')
        wdir = np.genfromtxt(wdir_path, delimiter=',')

        row = calculate_row(latitude, longitude)
        return tmp[row][2], wind[row][2], wdir[row][2]

    except FileNotFoundError:
        print(f"File not found for Day {day} at Altitude {altitude}. Skipping...")
        return None, None, None

def calculate_fitness(waypoints, altitude, day, speed_meters_per_second):
    distance = 0
    total_fuel_used = 0
    total_exploration_time = 0
    temperature_penalty = 0
    wind_penalty = 0
    direction_penalty = 0

    for i in range(len(waypoints) - 1):
        lat, lon = waypoints[i]
        next_lat, next_lon = waypoints[i + 1]

        # Calculate distance between waypoints
        distance_leg = geod.Inverse(lat, lon, next_lat, next_lon)['s12']

        # Get weather data for the next waypoint
        temperature, wind_speed, wind_direction = get_weather_data(day, altitude, next_lat, next_lon)

        if temperature is not None:
            total_air_temperature = (temperature - 273.15)  # Convert to Celsius
        else:
            total_air_temperature = 0  # Default value if temperature is not available

        # Use the fuel flow model to predict fuel flow based on total air temperature
        predicted_fuel_flow = fuel_flow_model.predict([[total_air_temperature]])[0]

        # Calculate time between waypoints and fuel used during the journey
        time_leg = distance_leg / speed_meters_per_second
        fuel_used_leg = predicted_fuel_flow * (time_leg / 3600)  # Convert fuel flow from kg/h to kg/s

        # Add fuel used during the leg to the total fuel used
        total_fuel_used += fuel_used_leg

        # Calculate exploration time for the leg
        total_exploration_time += time_leg

        # Calculate other penalties (temperature_penalty, wind_penalty, direction_penalty)
        temperature_penalty += 0.1 * total_air_temperature
        wind_penalty += 0  # Update with your wind penalty calculation
        direction_penalty += 0  # Update with your direction penalty calculation

    # Include exploration time in the fitness (multiply by total fuel flow)
    exploration_fuel_burned = total_exploration_time * total_fuel_used

    fitness = distance + temperature_penalty + wind_penalty + direction_penalty + exploration_fuel_burned
    return fitness


def calculate_time(waypoints, speed):
    time = 0
    for i in range(len(waypoints) - 1):
        lat1, lon1 = waypoints[i]
        lat2, lon2 = waypoints[i + 1]
        distance = geod.Inverse(lat1, lon1, lat2, lon2)['s12']
        time += distance / speed

    return time

def update_velocity(particle, global_best_waypoints, inertia_weight, cognitive_weight, social_weight, speed_meters_per_second):
    inertia_term = inertia_weight * particle.velocity
    cognitive_term = cognitive_weight * np.random.rand(*particle.velocity.shape) * (particle.best_waypoints - particle.waypoints)
    social_term = social_weight * np.random.rand(*particle.velocity.shape) * (global_best_waypoints - particle.waypoints)

    cognitive_term = cognitive_term[:, :2]
    social_term = social_term[:, :2]

    # Calculate exploration time for the particle
    exploration_time = np.sum(np.sqrt(np.sum((particle.waypoints[1:] - particle.waypoints[:-1]) ** 2, axis=1))) / speed_meters_per_second

    new_velocity = inertia_term + cognitive_term + social_term
    return new_velocity, exploration_time


def update_waypoints(particle, exploration_time):
    new_waypoints = particle.waypoints + particle.velocity
    return new_waypoints, exploration_time

def pso(initial_coord, final_coord, altitude, day, num_waypoints, num_particles, num_iterations, speed_meters_per_second):
    inertia_weight = 0.5
    cognitive_weight = 1.5
    social_weight = 1.5

    particles = [Particle(num_waypoints, initial_coord, final_coord, altitude, day) for _ in range(num_particles)]

    global_best_particle = min(particles, key=lambda p: calculate_fitness(p.waypoints, altitude, day, speed_meters_per_second))
    global_best_waypoints = np.copy(global_best_particle.waypoints)

    for iteration in range(num_iterations):
        for particle in particles:
            fitness = calculate_fitness(particle.waypoints, altitude, day, speed_meters_per_second)

            if fitness < particle.best_fitness:
                particle.best_fitness = fitness
                particle.best_waypoints = np.copy(particle.waypoints)

            if fitness < calculate_fitness(global_best_waypoints, altitude, day, speed_meters_per_second):
                global_best_waypoints = np.copy(particle.waypoints)

            # Update velocity and get exploration time
            particle.velocity, exploration_time = update_velocity(particle, global_best_waypoints, inertia_weight, cognitive_weight, social_weight, speed_meters_per_second)
            particle.waypoints, exploration_time = update_waypoints(particle, exploration_time)

    return global_best_waypoints, calculate_fitness(global_best_waypoints, altitude, day, speed_meters_per_second)

# Example usage
initial_coord = np.array([51, 1]) 
final_coord = np.array([41.300061, 2.075436])  
altitude = 1 # for weather data
day = 1 # for weather data
num_waypoints = 10
num_particles = 1
num_iterations = 2
speed_meters_per_second = 227.435889 # determined by historic data

best_waypoints, best_fitness = pso(initial_coord, final_coord, altitude, day, num_waypoints, num_particles, num_iterations, speed_meters_per_second)

# Calculate time based on the best waypoints and speed
time_taken = calculate_time(best_waypoints, speed_meters_per_second)

# Save waypoints as a CSV file
csv_directory = r'C:\Users\jayva\Documents\GitHub\OPTIMISATION\ROUTE output'
csv_path = os.path.join(csv_directory, "best_waypoints.csv")

with open(csv_path, "w", newline="") as csvfile:
    csvwriter = csv.writer(csvfile)
    csvwriter.writerow(["Latitude", "Longitude"]) 
    csvwriter.writerows(best_waypoints)

print(f"Best waypoints saved to {csv_path}")
